# Огляд результатів тестування алгоритмів сортування

## 1. Вступ
У цьому звіті проаналізовано результати роботи трьох алгоритмів сортування на основі вимірювання часу виконання для різних розмірів вхідних даних
1. **Timsort**
2. **Merge Sort**
3. **Insertion Sort**
Мета звіту: порівняння еффективності кожного алгоритму для практичного застосування.

---

## 2. Зведення тестових даних

| Розмір | Merge Sort (с) | Insertion Sort (с) | Timsort (с) |
|--------|----------------|---------------------|-------------|
| 10      | 0.000010 | 0.000004 | 0.000001 |
| 100     | 0.000053 | 0.000081 | 0.000006 |
| 500     | 0.000305 | 0.001888 | 0.000027 |
| 1000    | 0.000677 | 0.007294 | 0.000060 |
| 5000    | 0.004014 | 0.199629 | 0.000337 |
| 10000   | 0.008397 | 0.780748 | 0.000706 |
| 20000   | 0.018206 | 3.104690 | 0.001514 |
| 50000   | 0.049931 | 19.693310 | 0.004451 |
| 100000  | 0.110129 | 82.637497 | 0.009375 |

---

## 3. Аналіз результатів

### 3.1 Загальний рейтинг ефективності
Порядок ефективності залишається незмінним на всьому діапазоні тестів (від 10 до 100 000 елементів).
Для всіх розмірів масивів алгоритми розташовуються в такому порядку (найкращий → найгірший):

1. **Timsort**
2. **Merge Sort**
3. **Insertion Sort**

Timsort стабільно демонструє найкращу швидкість, тоді як Insertion Sort швидко втрачає продуктивність при збільшенні обсягу даних.
Розбіжності між алгоритмами ще помітніші при збільшенні обсягів даних.

---

### 3.2 Продуктивність Insertion Sort
Insertion Sort (вставка) демонструє стандартну поведінку алгоритму зі складністю **O(n²)**:
- На маленьких наборах (10–100) він працює прийнятно.
- На 1000 елементах стає у **~12× повільнішим**, ніж Merge Sort.
- На 100 000 елементах - у **~8800× повільнішим**, ніж Timsort.

Висновок: алгоритм придатний лише для дуже малих наборів даних.

---

### 3.3 Продуктивність Merge Sort
Merge Sort (злиття) забезпечує передбачувану масштабованість **O(n log n)**:
- Від 0.000010 с (10 елементів) до 0.110129 с (100 000 елементів).
- Приріст часу співвідноситься з логарифмічним фактором, що свідчить про коректність масштабування.
- На 100 000 елементах Merge Sort залишається **~11× повільнішим**, ніж Timsort.

Merge Sort добре підходить для великих наборів, але практично завжди поступається Timsort.

---

### 3.4 Продуктивність Timsort
Timsort демонструє найкращий час у кожному тесті:
- На 10 елементах - 0.000001 с  
- На 100 000 елементах - 0.009375 с  

Це показує майже лінійно-логарифмічну поведінку **O(n log n)**.

---

## 4. Ключові інсайти

### **Інсайт 1: Timsort - оптимальний алгоритм загального призначення**
Адаптивність та гібридний підхід забезпечують високу продуктивність.

---

### **Інсайт 2: Insertion Sort непридатний для великих наборів**
Час виконання стрімко зростає через квадратичну складність.

---

### **Інсайт 3: Merge Sort забезпечує стабільну масштабованість**
Алгоритм надійно працює на великих масивах та не має різких стрибків продуктивності.
Цей алгорітм підходить для систем, де Timsort недоступний або де потрібна передбачуваність поведінки (викладання, дослідницькі задачі).

---

## 5. Висновок
Результати тестування однозначно показують, що **Timsort є найефективнішим алгоритмом для всіх тестованих обсягів даних**, що робить його оптимальним вибором для реальних застосунків.  
Merge Sort демонструє хорошу масштабованість і може слугувати надійною альтернативою при спеціалізованих реалізаціях.  
Insertion Sort варто використовувати лише для дуже малих наборів даних через його різке падіння продуктивності при збільшенні розміру набору.
